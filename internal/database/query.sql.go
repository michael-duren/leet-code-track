// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package database

import (
	"context"
	"time"
)

const createProblem = `-- name: CreateProblem :one
INSERT INTO problems (problem_number, title, difficulty, pattern, notes)
VALUES (?, ?, ?, ?, ?)
RETURNING id
`

type CreateProblemParams struct {
	ProblemNumber int64   `json:"problem_number"`
	Title         string  `json:"title"`
	Difficulty    int64   `json:"difficulty"`
	Pattern       *string `json:"pattern"`
	Notes         *string `json:"notes"`
}

// 3. Insert new problem
func (q *Queries) CreateProblem(ctx context.Context, arg CreateProblemParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createProblem,
		arg.ProblemNumber,
		arg.Title,
		arg.Difficulty,
		arg.Pattern,
		arg.Notes,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteProblem = `-- name: DeleteProblem :exec
DELETE FROM problems WHERE id = ?
`

// 9. Delete problem
func (q *Queries) DeleteProblem(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteProblem, id)
	return err
}

const getProblemById = `-- name: GetProblemById :one
SELECT 
    id,
    problem_number,
    title,
    difficulty,
    date_attempted,
    first_review_date,
    second_review_date,
    final_review_date,
    status,
    pattern,
    notes
FROM problems 
WHERE id = ?
`

type GetProblemByIdRow struct {
	ID               int64       `json:"id"`
	ProblemNumber    int64       `json:"problem_number"`
	Title            string      `json:"title"`
	Difficulty       int64       `json:"difficulty"`
	DateAttempted    time.Time   `json:"date_attempted"`
	FirstReviewDate  interface{} `json:"first_review_date"`
	SecondReviewDate interface{} `json:"second_review_date"`
	FinalReviewDate  interface{} `json:"final_review_date"`
	Status           int64       `json:"status"`
	Pattern          *string     `json:"pattern"`
	Notes            *string     `json:"notes"`
}

// 10. Get problem by ID
func (q *Queries) GetProblemById(ctx context.Context, id int64) (GetProblemByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getProblemById, id)
	var i GetProblemByIdRow
	err := row.Scan(
		&i.ID,
		&i.ProblemNumber,
		&i.Title,
		&i.Difficulty,
		&i.DateAttempted,
		&i.FirstReviewDate,
		&i.SecondReviewDate,
		&i.FinalReviewDate,
		&i.Status,
		&i.Pattern,
		&i.Notes,
	)
	return i, err
}

const getProblemStatistics = `-- name: GetProblemStatistics :one
SELECT 
    COUNT(*) as total_problems,
    COUNT(CASE WHEN status = 4 THEN 1 END) as mastered_count,
    COUNT(CASE WHEN status = 1 THEN 1 END) as new_count,
    COUNT(CASE WHEN status = 2 THEN 1 END) as first_review_count,
    COUNT(CASE WHEN status = 3 THEN 1 END) as second_review_count,
    COUNT(CASE WHEN difficulty = 1 THEN 1 END) as easy_count,
    COUNT(CASE WHEN difficulty = 2 THEN 1 END) as medium_count,
    COUNT(CASE WHEN difficulty = 3 THEN 1 END) as hard_count
FROM problems
`

type GetProblemStatisticsRow struct {
	TotalProblems     int64 `json:"total_problems"`
	MasteredCount     int64 `json:"mastered_count"`
	NewCount          int64 `json:"new_count"`
	FirstReviewCount  int64 `json:"first_review_count"`
	SecondReviewCount int64 `json:"second_review_count"`
	EasyCount         int64 `json:"easy_count"`
	MediumCount       int64 `json:"medium_count"`
	HardCount         int64 `json:"hard_count"`
}

// 6. Get statistics
func (q *Queries) GetProblemStatistics(ctx context.Context) (GetProblemStatisticsRow, error) {
	row := q.db.QueryRowContext(ctx, getProblemStatistics)
	var i GetProblemStatisticsRow
	err := row.Scan(
		&i.TotalProblems,
		&i.MasteredCount,
		&i.NewCount,
		&i.FirstReviewCount,
		&i.SecondReviewCount,
		&i.EasyCount,
		&i.MediumCount,
		&i.HardCount,
	)
	return i, err
}

const getProblemsByTopic = `-- name: GetProblemsByTopic :many
SELECT 
    pattern,
    COUNT(*) as count,
    COUNT(CASE WHEN status = 4 THEN 1 END) as mastered,
    ROUND(COUNT(CASE WHEN status = 4 THEN 1 END) * 100.0 / COUNT(*), 1) as mastery_percentage
FROM problems 
WHERE pattern != ''
GROUP BY pattern
ORDER BY count DESC
`

type GetProblemsByTopicRow struct {
	Pattern           *string `json:"pattern"`
	Count             int64   `json:"count"`
	Mastered          int64   `json:"mastered"`
	MasteryPercentage float64 `json:"mastery_percentage"`
}

// 7. Get problems by pattern/topic
func (q *Queries) GetProblemsByTopic(ctx context.Context) ([]GetProblemsByTopicRow, error) {
	rows, err := q.db.QueryContext(ctx, getProblemsByTopic)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProblemsByTopicRow
	for rows.Next() {
		var i GetProblemsByTopicRow
		if err := rows.Scan(
			&i.Pattern,
			&i.Count,
			&i.Mastered,
			&i.MasteryPercentage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNextReviewedProblems = `-- name: ListNextReviewedProblems :many
SELECT 
    id,
    problem_number,
    title,
    difficulty,
    date_attempted,
    first_review_date,
    second_review_date,
    final_review_date,
    status,
    pattern,
    notes,
    CASE 
        WHEN status = 1 THEN date(date_attempted, '+3 days')
        WHEN status = 2 THEN date(first_review_date, '+7 days')
        WHEN status = 3 THEN date(second_review_date, '+20 days')
        ELSE NULL
    END as next_review_date,
    CASE 
        WHEN status = 4 THEN 'Mastered'
        WHEN status = 1 AND date(date_attempted, '+3 days') <= date('now') THEN 'Due'
        WHEN status = 2 AND date(first_review_date, '+7 days') <= date('now') THEN 'Due'
        WHEN status = 3 AND date(second_review_date, '+20 days') <= date('now') THEN 'Due'
        ELSE 'Scheduled'
    END as review_status
FROM problems 
ORDER BY date_attempted DESC
`

type ListNextReviewedProblemsRow struct {
	ID               int64       `json:"id"`
	ProblemNumber    int64       `json:"problem_number"`
	Title            string      `json:"title"`
	Difficulty       int64       `json:"difficulty"`
	DateAttempted    time.Time   `json:"date_attempted"`
	FirstReviewDate  interface{} `json:"first_review_date"`
	SecondReviewDate interface{} `json:"second_review_date"`
	FinalReviewDate  interface{} `json:"final_review_date"`
	Status           int64       `json:"status"`
	Pattern          *string     `json:"pattern"`
	Notes            *string     `json:"notes"`
	NextReviewDate   interface{} `json:"next_review_date"`
	ReviewStatus     string      `json:"review_status"`
}

// 2. Get all problems with calculated next review date
func (q *Queries) ListNextReviewedProblems(ctx context.Context) ([]ListNextReviewedProblemsRow, error) {
	rows, err := q.db.QueryContext(ctx, listNextReviewedProblems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNextReviewedProblemsRow
	for rows.Next() {
		var i ListNextReviewedProblemsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProblemNumber,
			&i.Title,
			&i.Difficulty,
			&i.DateAttempted,
			&i.FirstReviewDate,
			&i.SecondReviewDate,
			&i.FinalReviewDate,
			&i.Status,
			&i.Pattern,
			&i.Notes,
			&i.NextReviewDate,
			&i.ReviewStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProblems = `-- name: ListProblems :many
SELECT 
    id,
    problem_number,
    title,
    difficulty,
    date_attempted,
    first_review_date,
    second_review_date,
    final_review_date,
    status,
    pattern,
    notes,
    CASE 
        WHEN status = 1 THEN date(date_attempted, '+3 days')
        WHEN status = 2 THEN date(first_review_date, '+7 days')
        WHEN status = 3 THEN date(second_review_date, '+20 days')
        ELSE NULL
    END as next_review_date
FROM problems 
ORDER BY date_attempted ASC
`

type ListProblemsRow struct {
	ID               int64       `json:"id"`
	ProblemNumber    int64       `json:"problem_number"`
	Title            string      `json:"title"`
	Difficulty       int64       `json:"difficulty"`
	DateAttempted    time.Time   `json:"date_attempted"`
	FirstReviewDate  interface{} `json:"first_review_date"`
	SecondReviewDate interface{} `json:"second_review_date"`
	FinalReviewDate  interface{} `json:"final_review_date"`
	Status           int64       `json:"status"`
	Pattern          *string     `json:"pattern"`
	Notes            *string     `json:"notes"`
	NextReviewDate   interface{} `json:"next_review_date"`
}

func (q *Queries) ListProblems(ctx context.Context) ([]ListProblemsRow, error) {
	rows, err := q.db.QueryContext(ctx, listProblems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProblemsRow
	for rows.Next() {
		var i ListProblemsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProblemNumber,
			&i.Title,
			&i.Difficulty,
			&i.DateAttempted,
			&i.FirstReviewDate,
			&i.SecondReviewDate,
			&i.FinalReviewDate,
			&i.Status,
			&i.Pattern,
			&i.Notes,
			&i.NextReviewDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTodaysProblems = `-- name: ListTodaysProblems :many
SELECT 
    id,
    problem_number,
    title,
    difficulty,
    date_attempted,
    first_review_date,
    second_review_date,
    final_review_date,
    status,
    pattern,
    notes,
    CASE 
        WHEN status = 1 THEN date(date_attempted, '+3 days')
        WHEN status = 2 THEN date(first_review_date, '+7 days')
        WHEN status = 3 THEN date(second_review_date, '+20 days')
        ELSE NULL
    END as next_review_date
FROM problems 
WHERE status < 4  -- Not mastered
AND (
    (status = 1 AND date(date_attempted, '+3 days') <= date('now')) OR
    (status = 2 AND date(first_review_date, '+7 days') <= date('now')) OR
    (status = 3 AND date(second_review_date, '+20 days') <= date('now'))
)
ORDER BY date_attempted ASC
`

type ListTodaysProblemsRow struct {
	ID               int64       `json:"id"`
	ProblemNumber    int64       `json:"problem_number"`
	Title            string      `json:"title"`
	Difficulty       int64       `json:"difficulty"`
	DateAttempted    time.Time   `json:"date_attempted"`
	FirstReviewDate  interface{} `json:"first_review_date"`
	SecondReviewDate interface{} `json:"second_review_date"`
	FinalReviewDate  interface{} `json:"final_review_date"`
	Status           int64       `json:"status"`
	Pattern          *string     `json:"pattern"`
	Notes            *string     `json:"notes"`
	NextReviewDate   interface{} `json:"next_review_date"`
}

// 1. Get all problems that need review today
func (q *Queries) ListTodaysProblems(ctx context.Context) ([]ListTodaysProblemsRow, error) {
	rows, err := q.db.QueryContext(ctx, listTodaysProblems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTodaysProblemsRow
	for rows.Next() {
		var i ListTodaysProblemsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProblemNumber,
			&i.Title,
			&i.Difficulty,
			&i.DateAttempted,
			&i.FirstReviewDate,
			&i.SecondReviewDate,
			&i.FinalReviewDate,
			&i.Status,
			&i.Pattern,
			&i.Notes,
			&i.NextReviewDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetReviewTimer = `-- name: ResetReviewTimer :exec
UPDATE problems 
SET 
    first_review_date = CASE WHEN status = 2 THEN CURRENT_TIMESTAMP ELSE first_review_date END,
    second_review_date = CASE WHEN status = 3 THEN CURRENT_TIMESTAMP ELSE second_review_date END
WHERE id = ?
`

// 5. Mark problem as needing more review (reset review timer but keep status)
func (q *Queries) ResetReviewTimer(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, resetReviewTimer, id)
	return err
}

const searchProblems = `-- name: SearchProblems :many
SELECT 
    id,
    problem_number,
    title,
    difficulty,
    pattern,
    status
FROM problems 
WHERE title LIKE ? OR pattern LIKE ?
ORDER BY problem_number ASC
`

type SearchProblemsParams struct {
	Title   string  `json:"title"`
	Pattern *string `json:"pattern"`
}

type SearchProblemsRow struct {
	ID            int64   `json:"id"`
	ProblemNumber int64   `json:"problem_number"`
	Title         string  `json:"title"`
	Difficulty    int64   `json:"difficulty"`
	Pattern       *string `json:"pattern"`
	Status        int64   `json:"status"`
}

// 11. Search problems by title or pattern
func (q *Queries) SearchProblems(ctx context.Context, arg SearchProblemsParams) ([]SearchProblemsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchProblems, arg.Title, arg.Pattern)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchProblemsRow
	for rows.Next() {
		var i SearchProblemsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProblemNumber,
			&i.Title,
			&i.Difficulty,
			&i.Pattern,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateForFirstReview = `-- name: UpdateForFirstReview :exec
UPDATE problems 
SET status = 2, first_review_date = CURRENT_TIMESTAMP 
WHERE id = ? AND status = 1
RETURNING id
`

// 4. Update problem status (mark as reviewed)
func (q *Queries) UpdateForFirstReview(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, updateForFirstReview, id)
	return err
}

const updateForMasterReview = `-- name: UpdateForMasterReview :exec
UPDATE problems 
SET status = 4, final_review_date = CURRENT_TIMESTAMP 
WHERE id = ? AND status = 3
`

func (q *Queries) UpdateForMasterReview(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, updateForMasterReview, id)
	return err
}

const updateForSecondReview = `-- name: UpdateForSecondReview :exec
UPDATE problems 
SET status = 3, second_review_date = CURRENT_TIMESTAMP 
WHERE id = ? AND status = 2
`

// For second review
func (q *Queries) UpdateForSecondReview(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, updateForSecondReview, id)
	return err
}

const updateProblemNotes = `-- name: UpdateProblemNotes :exec
UPDATE problems 
SET notes = ? 
WHERE id = ?
`

type UpdateProblemNotesParams struct {
	Notes *string `json:"notes"`
	ID    int64   `json:"id"`
}

// 8. Update problem notes
func (q *Queries) UpdateProblemNotes(ctx context.Context, arg UpdateProblemNotesParams) error {
	_, err := q.db.ExecContext(ctx, updateProblemNotes, arg.Notes, arg.ID)
	return err
}
